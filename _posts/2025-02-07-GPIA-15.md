---
title: "[게임 프로그래머 입문 올인원] Select, WSAEventSelect"
date: 2025-02-07
categories:
  - 게임 프로그래머 입문 올인원
tags:
  - 네트워크 프로그래밍
---



{% capture notice-1 %}
#### Select 모델

* select 함수가 핵심이 되는 모델
* 소켓 함수 호출이 성공할 시점을 미리 알 수 있음
* 블로킹 소켓에서는 조건이 만족되지 않아서 블로킹되는 상황 예방하고, 논블로킹 소켓에서는 조건이 만족되지 않아서 불필요하게 반복 체크하는 상황을 예방
* 많은 과정을 거치기 때문에 비교적 속도가 느림
* fd_set의 크기가 작기 때문에 한도가 작음
{% endcapture %}

{% capture notice-2 %}
#### Select 모델 작동 과정

1. 읽기, 쓰기, 예외 관찰 대상 등록
2. select 함수 호출 (관찰 시작)
3. 적어도 하나의 소켓이 준비되면 리턴 (다른 소켓들은 알아서 제외)
4. 나머지 소켓 체크
{% endcapture %}

{% capture notice-3 %}
#### WSAEventSelect 모델

* WSAEventSelect가 핵심이 되는 모델
* Select 모델과 마찬가지로 소켓 함수 호출이 성공할 시점을 미리 알 수 있음
* 소켓과 관련된 네트워크 이벤트를 이벤트 객체를 통해 감지
* 윈도우 환경에서만 작동함
{% endcapture %}

{% capture notice-4 %}
#### WSAEventSelect 모델 작동 과정

1. 이벤트 객체 생성
2. 소켓과 이벤트 객체 연동
3. 이벤트 객체 신호 상태 감지
4. 네트워크 이벤트 확인
{% endcapture %}



<div class="notice">
  {{ notice-1 | markdownify }}
</div>

<div class="notice">
  {{ notice-2 | markdownify }}
</div>

#### Server.cpp
```cpp
#include "pch.h"

const int32 BUFSIZE = 1000;

// 연결된 client를 나타내는 구조체
struct Session
{
	SOCKET socket = INVALID_SOCKET;
	char recvBuffer[BUFSIZE] = {};
	int32 recvBytes = 0;
};

int main()
{
	SocketUtils::Init();

	SOCKET listenSocket = ::socket(AF_INET, SOCK_STREAM, 0);
	if (listenSocket == INVALID_SOCKET)
		return 0;

	u_long on = 1;
	if (::ioctlsocket(listenSocket, FIONBIO, &on) == INVALID_SOCKET)
		return 0;

	SocketUtils::SetReuseAddress(listenSocket, true);
	
	if (SocketUtils::BindAnyAddress(listenSocket, 7777) == false)
		return 0;

	SocketUtils::Listen(listenSocket);

	SOCKADDR_IN clientAddr;
	int32 addrLen = sizeof(clientAddr);

	vector<Session> sessions;
	sessions.reserve(100);

	fd_set reads;
	fd_set writes;

	while (true)
	{
		// 초기화
		FD_ZERO(&reads);

		// 1) 관찰 대상 등록
		// listen socket 등록
		FD_SET(listenSocket, &reads);

		// 연결된 클라이언트들의 소켓 등록
		for (Session& s : sessions)
			FD_SET(s.socket, &reads);

		// 2) select 함수 호출 (관찰 시작)
		// 마지막 인자로 시간 설정 가능
		int32 retVal = ::select(0, &reads, nullptr, nullptr, nullptr);
		if (retVal == SOCKET_ERROR)
			break;

		// 3) 적어도 하나의 소켓이 준비되면 리턴
		// listen socket이 준비될 경우
		if (FD_ISSET(listenSocket, &reads))
		{
			SOCKADDR_IN clientAddr;
			int32 addrLen = sizeof(clientAddr);
			SOCKET clientSocket = ::accept(listenSocket, (SOCKADDR*)&clientAddr, &addrLen);

			// 잘못된 소켓이 아닐 때
			if (clientSocket != INVALID_SOCKET)
			{
				// client와 연결이 아직 준비되지 않은 경우, 연결될 때까지 시도
				if (::WSAGetLastError() == WSAEWOULDBLOCK)
					continue;

				cout << "Client Connected" << endl;
				// 새로 연결된 클라이언트를 세션 생성 후 추가
				sessions.push_back(Session{ clientSocket });
			}
		}

		// 4) 나머지 소켓 체크
		for (Session& s : sessions)
		{
			if (FD_ISSET(s.socket, &reads))
			{
				// 수신
				int32 recvLen = ::recv(s.socket, s.recvBuffer, BUFSIZE, 0);
				if (recvLen <= 0)
				{
					continue;
				}

				cout << "Recv Data = " << s.recvBuffer << endl;
				s.recvBytes = recvLen;
				cout << "RecvLen = " << recvLen << endl;
			}
		}
	}

	SocketUtils::Close(listenSocket);
}
```
# --------------------------------------------------------------------------------
<div class="notice">
  {{ notice-3 | markdownify }}
</div>

<div class="notice">
  {{ notice-4 | markdownify }}
</div>

#### Server.cpp
```cpp
#include "pch.h"

const int32 BUFSIZE = 1000;

struct Session
{
	SOCKET socket = INVALID_SOCKET;
	char recvBuffer[BUFSIZE] = {};
	int32 recvBytes = 0;
};

int main()
{
	SocketUtils::Init();

	SOCKET listenSocket = ::socket(AF_INET, SOCK_STREAM, 0);
	if (listenSocket == INVALID_SOCKET)
		return 0;

	u_long on = 1;
	if (::ioctlsocket(listenSocket, FIONBIO, &on) == INVALID_SOCKET)
		return 0;

	SocketUtils::SetReuseAddress(listenSocket, true);
	
	if (SocketUtils::BindAnyAddress(listenSocket, 7777) == false)
		return 0;

	SocketUtils::Listen(listenSocket);

	vector<WSAEVENT> wsaEvents;
	vector<Session> sessions;
	sessions.reserve(100);

	// 1) listen socket 이벤트 객체 생성
	WSAEVENT listenEvent = ::WSACreateEvent();
	wsaEvents.push_back(listenEvent);
	sessions.push_back(Session{ listenSocket });

	// 2) listen socket과 이벤트 객체 연동
	if (::WSAEventSelect(listenSocket, listenEvent, FD_ACCEPT | FD_CLOSE) == SOCKET_ERROR)
		return 0;

	while (true)
	{
		// 3) 이벤트 객체 신호 상태 감지
		int32 index = ::WSAWaitForMultipleEvents(wsaEvents.size(), &wsaEvents[0], FALSE, WSA_INFINITE, FALSE);
		// 함수 호출 자체가 실패한 경우 재시도
		if (index == WSA_WAIT_FAILED)
			continue;

		// 실제 인덱스 계산
		index -= WSA_WAIT_EVENT_0;

		// 4) 네트워크 이벤트 확인
		WSANETWORKEVENTS networkEvents;
		if (::WSAEnumNetworkEvents(sessions[index].socket, wsaEvents[index], &networkEvents) == SOCKET_ERROR)
			continue;

		// 새로운 연결 요청 발생 시
		if (networkEvents.lNetworkEvents & FD_ACCEPT)
		{
			// 연결 요청 중 문제가 생길 경우 재시도
			if (networkEvents.iErrorCode[FD_ACCEPT_BIT] != 0)
				continue;

			SOCKADDR_IN clientAddr;
			int32 addrLen = sizeof(clientAddr);

			SOCKET clientSocket = ::accept(listenSocket, (SOCKADDR*)&clientAddr, &addrLen);
			if (clientSocket != INVALID_SOCKET)
			{
				cout << "Client Connected" << endl;

				// 1) clientSocket 이벤트 객체 생성
				WSAEVENT clientEvent = ::WSACreateEvent();
				wsaEvents.push_back(clientEvent);
				sessions.push_back(Session{ clientSocket });
				// 2) clientSocket과 이벤트 객체 연동
				if (::WSAEventSelect(clientSocket, clientEvent, FD_READ | FD_WRITE | FD_CLOSE) == SOCKET_ERROR)
					return 0;
			}
		}

		// 수신 데이터가 있을 시
		if (networkEvents.lNetworkEvents & FD_READ)
		{
			if (networkEvents.iErrorCode[FD_READ_BIT] != 0)
				continue;

			// 수신 데이터를 송신한 client 찾기
			Session& s = sessions[index];

			int32 recvLen = ::recv(s.socket, s.recvBuffer, BUFSIZE, 0);
			if (recvLen == SOCKET_ERROR && ::WSAGetLastError() != WSAEWOULDBLOCK)
			{
				if (recvLen <= 0)
				{
					continue;
				}
			}

			s.recvBytes = recvLen;
			cout << "Recv Data = " << s.recvBuffer << endl;
			cout << "RecvLen = " << recvLen << endl;
		}
	}

	SocketUtils::Close(listenSocket);
}
```

출처: [인프런: 게임 프로그래머 입문 올인원][source]

[source]: https://www.inflearn.com/course/%EA%B2%8C%EC%9E%84-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-%EC%9E%85%EB%AC%B8-%EC%98%AC%EC%9D%B8%EC%9B%90-rookiss/dashboard