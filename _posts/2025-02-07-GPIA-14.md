---
title: "[게임 프로그래머 입문 올인원] 논블로킹 소켓"
date: 2025-02-07
categories:
  - 게임 프로그래머 입문 올인원
tags:
  - 네트워크 프로그래밍
---



{% capture notice-1 %}
#### 소켓 옵션

*  소켓의 동작 방식을 제어하거나 설정을 커스터마이즈할 수 있도록 도와주는 기능
{% endcapture %}

{% capture notice-2 %}
#### 자주 사용되는 소켓 옵션

* SO_KEEPALIVE: 주기적으로 연결 상태 확인하여, 비활성화된 연결 끊기
* SO_LINGER: 연결이 끊길 때 송신 버퍼에 있는 데이터를 보내려고 지정된 시간동안 시도
* SO_SNDBUF: 송신 버퍼 크기를 설정하거나 가져오기
* SO_RECVBUF: 수신 버퍼 크기를 설정하거나 가져오기
* SO_REUSEADDR: 사용했던 주소 다시 사용할 수 있도록 허용
* TCP_NODELAY: Nagle 알고리즘 비활성화
{% endcapture %}

{% capture notice-3 %}
#### 소켓 옵션 설정 함수 인자

* level: 소켓 옵션이 적용될 프로토콜 레벨
* optname: 설정하려는 옵셥의 이름
* opval: 설정하려는 옵션의 값
{% endcapture %}

{% capture notice-4 %}
#### Nagle 알고리즘

* 데이터의 크기가 작으면 기다렸다가 모아서 한 번에 보내는 알고리즘
* 작은 패킷이 보내짐으로써 낭비되는 것을 방지
* 하지만 게임에서는 바로바로 데이터를 보내야하는 경우가 많기 때문에 보통은 사용하지 않음
{% endcapture %}



<div class="notice">
  {{ notice-1 | markdownify }}
</div>

<div class="notice">
  {{ notice-2 | markdownify }}
</div>

<div class="notice">
  {{ notice-3 | markdownify }}
</div>

#### 소켓 옵션 사용 예시
```cpp
// SO_KEEPALIVE
bool enable = true;
::setsockopt(listenSocket, SOL_SOCKET, SO_KEEPALIVE, (char*)&enable, sizeof(enable));

// SO_SNDBUF
int32 sendBufferSize;
int32 optionLen = sizeof(sendBufferSize);
::getsockopt(listenSocket, SOL_SOCKET, SO_SNDBUF, (char*)&sendBufferSize, &optionLen);
cout << "송신 버퍼 크기: " << sendBufferSize << endl;

// SO_REUSEADDR
bool enable = true;
::setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&enable, sizeof(enable));
```
# ---------------------------------------------------------------------------------
<div class="notice">
  {{ notice-4 | markdownify }}
</div>

# ---------------------------------------------------------------------------------
#### 소켓 사용을 간편화하기 위해 ServerCore 프로젝트에 Network 필터 추가 후, SocketUtils 클래스 추가
# ---------------------------------------------------------------------------------
#### SocketUtils.h
```cpp
class SocketUtils
{
public:
	// 비동기 통신을 위한 윈도우 내부 함수 포인터
	static LPFN_CONNECTEX ConnectEx;
	static LPFN_DISCONNECTEX DisconnectEx;
	static LPFN_ACCEPTEX AcceptEx;

public:
	static void Init();
	static void Clear();

	static bool BindWindowsFunction(SOCKET socket, GUID guid, LPVOID* fn);
	static SOCKET CreateSocket();

	// 소켓 옵션 설정 함수
	// 소켓 종료 시, 송신 데이터가 남아 있을 경우 대기 여부 지정
	static bool SetLinger(SOCKET socket, uint16 onoff, uint16 linger);
	// 서버 재시작 시 동일 포트 재사용 허용
	static bool SetReuseAddress(SOCKET socket, bool flag);
	// 수신 버퍼 크기 조절
	static bool SetRecvBufferSize(SOCKET socket, int32 size);
	// 송신 버퍼 크기 조절
	static bool SetSendBufferSize(SOCKET socket, int32 size);
	// Nagle 알고리즘 끄기(지연없이 즉시 송신)
	static bool SetTcpNoDelay(SOCKET socket, bool flag);

	static bool SetUpdateAcceptSocket(SOCKET socket, SOCKET listenSocket);

	// 소켓에 IP/포트 정보 연결
	static bool Bind(SOCKET socket, SOCKADDR_IN netAddr);
	static bool BindAnyAddress(SOCKET socket, uint16 port);

	static bool Listen(SOCKET socket, int32 backlog = SOMAXCONN);
	static void Close(SOCKET& socket);
};

// 소켓 옵션 템플릿
template<typename T>
static inline bool SetSockOpt(SOCKET socket, int32 level, int32 optName, T optVal)
{
	// 소켓 옵션 설정
	return SOCKET_ERROR != ::setsockopt(socket, level, optName, reinterpret_cast<char*>(&optVal), sizeof(T));
}
```

#### SocketUtils.cpp
```cpp
#include "pch.h"
#include "SocketUtils.h"

LPFN_CONNECTEX SocketUtils::ConnectEx = nullptr;
LPFN_DISCONNECTEX SocketUtils::DisconnectEx = nullptr;
LPFN_ACCEPTEX SocketUtils::AcceptEx = nullptr;

void SocketUtils::Init()
{
	// WinSock 라이브러리 사용을 위한 초기화
	WSADATA wsaData;
	assert(::WSAStartup(MAKEWORD(2, 2), OUT &wsaData) == 0);
	
	SOCKET dummySocket = CreateSocket();
	// 함수 포인터에 함수 연결
	assert(BindWindowsFunction(dummySocket, WSAID_CONNECTEX, reinterpret_cast<LPVOID*>(&ConnectEx)));
	assert(BindWindowsFunction(dummySocket, WSAID_DISCONNECTEX, reinterpret_cast<LPVOID*>(&DisconnectEx)));
	assert(BindWindowsFunction(dummySocket, WSAID_ACCEPTEX, reinterpret_cast<LPVOID*>(&AcceptEx)));
	
	Close(dummySocket);
}

void SocketUtils::Clear()
{
	::WSACleanup();
}

bool SocketUtils::BindWindowsFunction(SOCKET socket, GUID guid, LPVOID* fn)
{
	DWORD bytes = 0;
	// 비동기 통신을 위한 윈도우 내부 함수 가져오기
	return SOCKET_ERROR != ::WSAIoctl(socket, SIO_GET_EXTENSION_FUNCTION_POINTER, &guid, sizeof(guid), fn, sizeof(*fn), OUT & bytes, NULL, NULL);
}

SOCKET SocketUtils::CreateSocket()
{
	// 비동기 통신을 지원하는 TCP 소켓 생성
	return ::WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);
}

bool SocketUtils::SetLinger(SOCKET socket, uint16 onoff, uint16 linger)
{
	LINGER option;
	// 대기 여부
	option.l_onoff = onoff;
	// 종료 전 최대 대기 시간
	option.l_linger = linger;
	return SetSockOpt(socket, SOL_SOCKET, SO_LINGER, option);
}

bool SocketUtils::SetReuseAddress(SOCKET socket, bool flag)
{
	return SetSockOpt(socket, SOL_SOCKET, SO_REUSEADDR, flag);
}

bool SocketUtils::SetRecvBufferSize(SOCKET socket, int32 size)
{
	return SetSockOpt(socket, SOL_SOCKET, SO_RCVBUF, size);
}

bool SocketUtils::SetSendBufferSize(SOCKET socket, int32 size)
{
	return SetSockOpt(socket, SOL_SOCKET, SO_SNDBUF, size);
}

bool SocketUtils::SetTcpNoDelay(SOCKET socket, bool flag)
{
	return SetSockOpt(socket, SOL_SOCKET, TCP_NODELAY, flag);
}

bool SocketUtils::SetUpdateAcceptSocket(SOCKET socket, SOCKET listenSocket)
{
	return SetSockOpt(socket, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT, listenSocket);
}

bool SocketUtils::Bind(SOCKET socket, SOCKADDR_IN sockAddr)
{
	return SOCKET_ERROR != ::bind(socket, (SOCKADDR*)&sockAddr, sizeof(SOCKADDR_IN));
}

bool SocketUtils::BindAnyAddress(SOCKET socket, uint16 port)
{
	SOCKADDR_IN myAddress;
	myAddress.sin_family = AF_INET;
	// 아무 IP로 접근해도 수락
	myAddress.sin_addr.s_addr = ::htonl(INADDR_ANY);
	myAddress.sin_port = ::htons(port);

	return SOCKET_ERROR != ::bind(socket, reinterpret_cast<const SOCKADDR*>(&myAddress), sizeof(myAddress));
}

bool SocketUtils::Listen(SOCKET socket, int32 backlog)
{
	// socket을 수신 대기 상태로 설정
	return SOCKET_ERROR != ::listen(socket, backlog);
}

void SocketUtils::Close(SOCKET& socket)
{
	if (socket != INVALID_SOCKET)
		::closesocket(socket);
	socket = INVALID_SOCKET;
}
```
# ---------------------------------------------------------------------------------
#### CorePch에 SocketUtils 클래스를 위한 헤더 추가 및 SocketUtile 헤더 추가

#### CorePch.h
```cpp
#include <mswsock.h>
#include <assert.h>

#include "SocketUtils.h"
```
# ---------------------------------------------------------------------------------
#### SocketUtils를 활용한 논블로킹 소켓 코드
# ---------------------------------------------------------------------------------
#### Server.cpp
```cpp
#include "pch.h"

int main()
{
	// 논블로킹 소켓 프로그래밍을 위한 초기화
	SocketUtils::Init();

	// listen socket IPv4, TCP로 생성
	SOCKET listenSocket = ::socket(AF_INET, SOCK_STREAM, 0);
	if (listenSocket == INVALID_SOCKET)
		return 0;
	
	// listen socket을 논블로킹 모드로 전환
	u_long on = 1;
	if (::ioctlsocket(listenSocket, FIONBIO, &on) == INVALID_SOCKET)
		return 0;
	
	// 서버 재시작 시 동일 포트 재사용 허용
	SocketUtils::SetReuseAddress(listenSocket, true);

	// 아무 IP 접근 허용으로 바인딩
	if (SocketUtils::BindAnyAddress(listenSocket, 7777) == false)
		return 0;

	if (SocketUtils::Listen(listenSocket, SOMAXCONN) == false)
		return 0;

	SOCKADDR_IN clientAddr;
	int32 addrLen = sizeof(clientAddr);

	while (true)
	{
		// client 접속 시 통신하기 위한 client socket 생성
		SOCKET clientSocket = ::accept(listenSocket, (SOCKADDR*)&clientAddr, &addrLen);
		if (clientSocket == INVALID_SOCKET)
		{
			// 작업이 아직 없어서 실패한 경우, 연결될 때까지 계속 확인
			if (::WSAGetLastError() == WSAEWOULDBLOCK)
				continue;
		}

		cout << "Client Connected!" << endl;

		while (true)
		{
			char recvBuffer[1000];
			// 수신
			int32 recvLen = ::recv(clientSocket, recvBuffer, sizeof(recvBuffer), 0);
			if (recvLen == SOCKET_ERROR)
			{
				// 수신 버퍼의 내용이 없을 경우, 수신 버퍼에 데이터가 있는지 계속 확인
				if (::WSAGetLastError() == WSAEWOULDBLOCK)
					continue;
 
				break;
			}

			cout << "Recv Data = " << recvBuffer << endl;
			cout << "Recv Data len = " << recvLen << endl;
		}
	}

	SocketUtils::Close(listenSocket);
}
```

#### DummyClient.cpp
```cpp
#include "pch.h"

int main()
{
	SocketUtils::Init();

	SOCKET clientSocket = ::socket(AF_INET, SOCK_STREAM, 0);
	if (clientSocket == INVALID_SOCKET)
		return 0;

	u_long on = 1;
	if (::ioctlsocket(clientSocket, FIONBIO, &on) == INVALID_SOCKET)
		return 0;

	SOCKADDR_IN serverAddr;
	::memset(&serverAddr, 0, sizeof(serverAddr));
	serverAddr.sin_family = AF_INET;
	::inet_pton(AF_INET, "127.0.0.1", &serverAddr.sin_addr);
	serverAddr.sin_port = ::htons(7777);

	while (true)
	{
		// server와 연결 시도
		if (::connect(clientSocket, (SOCKADDR*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR)
		{
			// 아직 연결이 되지 않아 실패할 경우, 연결될 때까지 계속 시도
			if (::WSAGetLastError() == WSAEWOULDBLOCK)
				continue;

			// 연결된 경우 탈출
			if (::WSAGetLastError() == WSAEISCONN)
				break;
		}
	}

	while (true)
	{
		char sendBuffer[100] = "Hello I am Client!";
		int32 sendLen = sizeof(sendBuffer);

		// 송신
		if (::send(clientSocket, sendBuffer, sendLen, 0) == SOCKET_ERROR)
		{
			// 송신이 지연되어 실패할 경우, 완료될 때까지 계속 시도
			if (::WSAGetLastError() == WSAEWOULDBLOCK)
				continue;

			cout << "Send Data ! Len = " << sendLen << endl;			
		}

		// 대기
		this_thread::sleep_for(1s);
	}

	SocketUtils::Close(clientSocket);
}
```

출처: [인프런: 게임 프로그래머 입문 올인원][source]

[source]: https://www.inflearn.com/course/%EA%B2%8C%EC%9E%84-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-%EC%9E%85%EB%AC%B8-%EC%98%AC%EC%9D%B8%EC%9B%90-rookiss/dashboard