---
title: "[게임 프로그래머 입문 올인원] IocpCore"
date: 2025-02-09
categories:
  - 게임 프로그래머 입문 올인원
tags:
  - 게임 서버 엔진
---



{% capture notice-1 %}
* Iocp 큐(CP)를 담당하는 클래스
* IocpObject: Iocp 큐에 들어가는 관찰 대상들의 상위 클래스
{% endcapture %}

{% capture notice-2 %}
* 작업의 상태를 나타내는 구조체
* overlapped를 포함하는 방식과 상속받는 방식이 있으며, 상속받는 방식일 때는 가상함수 사용에 주의해햐 함
{% endcapture %}

{% capture notice-3 %}
* listenSocket 역할을 하는 클래스
{% endcapture %}

{% capture notice-4 %}
* 네트워크 주소를 편하게 관리하기 위한 클래스
{% endcapture %}

{% capture notice-5 %}
* 연결된 상대방을 표현하는 클래스
* CP에 등록해야하기 때문에 IocpObject를 상속 받음
{% endcapture %}



#### IOCP를 사용하기 위한 클래스와 구조체 추가
# --------------------------------------------------------------------------------
#### IocpCore.h
```cpp
// Iocp 큐에 들어가는 관찰 대상들의 상위 클래스
class IocpObject
{
public:
	virtual ~IocpObject(){}

	virtual HANDLE GetHandle() abstract;
	virtual void Dispatch(struct IocpEvent* iocpEvent, int32 numOfBytes = 0) abstract;
};

// Iocp 큐(CP)를 담당하는 클래스
class IocpCore
{
public:
	IocpCore();
	~IocpCore();

	HANDLE	GetHandle() { return _iocpHandle; }

	// 소켓을 CP에 등록
	bool Register(class IocpObject* iocpObject);
	// 호출된 작업 꺼내기
	bool Dispatch(uint32 timeoutMs = INFINITE);

private:
	HANDLE _iocpHandle;
};

// 임시 전역 변수
extern IocpCore GIocpCore;
```

#### IocpCore.cpp
```cpp
#include "pch.h"
#include "IocpCore.h"
#include "IocpEvent.h"

IocpCore GIocpCore;

IocpCore::IocpCore()
{
	// CP 생성
	_iocpHandle = ::CreateIoCompletionPort(INVALID_HANDLE_VALUE, 0, 0, 0);
	assert(_iocpHandle != INVALID_HANDLE_VALUE);
}

IocpCore::~IocpCore()
{
	::CloseHandle(_iocpHandle);
}

bool IocpCore::Register(IocpObject* iocpObject)
{
	// 소켓을 CP에 등록
	return ::CreateIoCompletionPort(iocpObject->GetHandle(), _iocpHandle, reinterpret_cast<ULONG_PTR>(iocpObject), 0);
}

bool IocpCore::Dispatch(uint32 timeoutMs)
{
	DWORD numOfBytes = 0;
	IocpObject* iocpObject = nullptr;
	IocpEvent* iocpEvent = nullptr;

	// CP에 작업이 있는지 확인
	if (::GetQueuedCompletionStatus(_iocpHandle, OUT &numOfBytes, OUT reinterpret_cast<PULONG_PTR>(&iocpObject), OUT reinterpret_cast<LPOVERLAPPED*>(&iocpEvent), timeoutMs))
	{
		// 작업이 있다면 꺼내기
		iocpObject->Dispatch(iocpEvent, numOfBytes);
	}
	else
	{
		int32 errCode = ::WSAGetLastError();
		switch (errCode)
		{
		case WAIT_TIMEOUT: // 시간 초과
			return false;
		default: // 지정한 오류가 아니라면 작업 꺼내기
			iocpObject->Dispatch(iocpEvent, numOfBytes);
			break;
		}
	}

	return true;
}
```

<div class="notice">
  {{ notice-1 | markdownify }}
</div>

#### IocpEvent.h
```cpp
class Session;

enum class EventType : uint8
{
	Connect,
	Disconnect,
	Accept,
	Recv,
	Send
};

struct IocpEvent : public OVERLAPPED
{
	IocpEvent(EventType type);

	void Init();

	EventType type;
	Session* session = nullptr;
};
```

#### IocpEvent.cpp
```cpp
#include "pch.h"
#include "IocpEvent.h"

IocpEvent::IocpEvent(EventType type) : type(type)
{
	Init();
}

void IocpEvent::Init()
{
	hEvent = 0;
	Internal = 0;
	InternalHigh = 0;
	Offset = 0;
	OffsetHigh = 0;
}
```

<div class="notice">
  {{ notice-2 | markdownify }}
</div>

#### Listener.h
```cpp
#include "IocpCore.h"
#include "NetAddress.h"

class Listener : public IocpObject
{
public:
	Listener() = default;
	~Listener();

public:
	// session 의 접속 요청을 받을 준비 시작
	bool StartAccept(NetAddress netAddress);
	void CloseSocket();

public:
	virtual HANDLE GetHandle() override;
	// CP 작업 처리
	virtual void Dispatch(struct IocpEvent* iocpEvent, int32 numOfBytes = 0) override;

private:
	// 접속 이벤트 등록
	void RegisterAccept(IocpEvent* acceptEvent);
	// 접속 이벤트 완료 처리
	void ProcessAccept(IocpEvent* acceptEvent);

protected:
	SOCKET _socket = INVALID_SOCKET;
	vector<IocpEvent*> _acceptEvents;
};
```

#### Listener.cpp
```cpp
#include "pch.h"
#include "Listener.h"
#include "IocpEvent.h"
#include "Session.h"

Listener::~Listener()
{
	SocketUtils::Close(_socket);

	// 남은 접속 이벤트 삭제
	for (IocpEvent* acceptEvent : _acceptEvents)
	{
		delete acceptEvent;
	}
}

bool Listener::StartAccept(NetAddress netAddress)
{
	// 소켓 생성
	_socket = SocketUtils::CreateSocket();
	if (_socket == INVALID_SOCKET)
		return false;

	// 소켓을 CP에 등록
	if (GIocpCore.Register(this) == false)
		return false;

	// 서버 재시작 시 동일 포트 재사용 허용
	if (SocketUtils::SetReuseAddress(_socket, true) == false)
		return false;

	// 소켓 종료 시, 송신 데이터가 남아 있어도 대기하지 않도록 설정
	if (SocketUtils::SetLinger(_socket, 0, 0) == false)
		return false;

	// 소켓에 IP/포트 정보 연결
	if (SocketUtils::Bind(_socket, netAddress) == false)
		return false;

	// Client 연결 대기 시작 
	if (SocketUtils::Listen(_socket) == false)
		return false;
	
	// 접속 이벤트 생성 및 등록 
	const int32 acceptCount = 1;
	for (int32 i = 0; i < acceptCount; i++)
	{
		IocpEvent* acceptEvent = new IocpEvent(EventType::Accept);
		_acceptEvents.push_back(acceptEvent);
		// 접속 이벤트 등록
		RegisterAccept(acceptEvent);
	}

	return false;
}

void Listener::CloseSocket()
{
	SocketUtils::Close(_socket);
}

HANDLE Listener::GetHandle()
{
	return reinterpret_cast<HANDLE>(_socket);
}

void Listener::Dispatch(IocpEvent* acceptEvent, int32 numOfBytes)
{
	assert(acceptEvent->type == EventType::Accept);
	// 접속 이벤트 완료 처리
	ProcessAccept(acceptEvent);
}

void Listener::RegisterAccept(IocpEvent* acceptEvent)
{
	// session 생성 후, 접속 이벤트와 연결
	Session* session = new Session();
	acceptEvent->Init();
	acceptEvent->session = session;

	DWORD bytesReceived = 0;
	// Client와 연결 시도
	if (false == SocketUtils::AcceptEx(_socket, session->GetSocket(), session->_recvBuffer, 0, sizeof(SOCKADDR_IN) + 16, sizeof(SOCKADDR_IN) + 16, OUT &bytesReceived, static_cast<LPOVERLAPPED>(acceptEvent)))
	{
		const int32 errorCode = ::WSAGetLastError();
		if (errorCode != WSA_IO_PENDING)
		{
			// 아직 연결중이라면 재시도
			RegisterAccept(acceptEvent);
		}
	}
}

void Listener::ProcessAccept(IocpEvent* acceptEvent)
{
	Session* session = acceptEvent->session;

	// 해당 session이 어느 listen socket에 접속되었는지 확인
	if (false == SocketUtils::SetUpdateAcceptSocket(session->GetSocket(), _socket))
	{
		// 접속한 listen socket이 없으면 접속 요청 재시도
		RegisterAccept(acceptEvent);
		return;
	}

	SOCKADDR_IN sockAddress;
	int32 sizeOfSockAddr = sizeof(sockAddress);
	// Client의 IP/포트 정보 추출
	if (SOCKET_ERROR == ::getpeername(session->GetSocket(), OUT reinterpret_cast<SOCKADDR*>(&sockAddress), &sizeOfSockAddr))
	{
		// 추출 실패 시 접속 요청 재시도
		RegisterAccept(acceptEvent);
		return;
	}

	cout << "Client Connected!" << endl;

	// 추출한 정보 저장
	session->SetNetAddress(NetAddress(sockAddress));
	// 다음 client 접속 이벤트 등록
	RegisterAccept(acceptEvent);
}
```

<div class="notice">
  {{ notice-3 | markdownify }}
</div>

#### NetAddress.h
```cpp
class NetAddress
{
public:
	NetAddress() = default;
	NetAddress(SOCKADDR_IN sockAddr);
	NetAddress(wstring ip, uint16 port);

	SOCKADDR_IN& GetSockAddr() { return _sockAddr; }
	wstring GetIpAddress();
	uint16 GetPort() { return ::ntohs(_sockAddr.sin_port); }

public:
	static IN_ADDR Ip2Address(const WCHAR* ip);

private:
	SOCKADDR_IN _sockAddr = {};
};
```

#### NetAddress.cpp
```cpp
#include "pch.h"
#include "NetAddress.h"

NetAddress::NetAddress(SOCKADDR_IN sockAddr) : _sockAddr(sockAddr)
{
}

NetAddress::NetAddress(wstring ip, uint16 port)
{
	::memset(&_sockAddr, 0, sizeof(_sockAddr));
	// IPv4
	_sockAddr.sin_family = AF_INET;
	// IP주소를 네트워크용 바이너리 주소로 변환
	_sockAddr.sin_addr = Ip2Address(ip.c_str());
	// big endian으로 포트 번호 저장
	_sockAddr.sin_port = ::htons(port);
}

wstring NetAddress::GetIpAddress()
{
	WCHAR buffer[100];
	::InetNtopW(AF_INET, &_sockAddr.sin_addr, buffer, len32(buffer));
	return wstring(buffer);
}

IN_ADDR NetAddress::Ip2Address(const WCHAR* ip)
{
	IN_ADDR address;
	::InetPtonW(AF_INET, ip, &address);
	return address;
}
```

<div class="notice">
  {{ notice-4 | markdownify }}
</div>

#### Session.h
```cpp
#include "IocpCore.h"
#include "IocpEvent.h"
#include "NetAddress.h"

class Session : public IocpObject
{
public:
	Session();
	virtual ~Session();

public:
	void SetNetAddress(NetAddress address) { _netAddress = address; }
	NetAddress GetAddress() { return _netAddress; }
	SOCKET GetSocket() { return _socket; }

public:
	virtual HANDLE GetHandle() override;
	// CP 작업 처리
	virtual void Dispatch(struct IocpEvent* iocpEvent, int32 numOfBytes = 0) override;

public:
	// 임시 수신 버퍼
	char _recvBuffer[1000];

private:
	SOCKET _socket = INVALID_SOCKET;
	NetAddress netAddress = {};
	Atomic<bool> _connected = false;
};
```

#### Session.cpp
```cpp
#include "pch.h"
#include "Session.h"

Session::Session()
{
	_socket = SocketUtils::CreateSocket();
}

Session::~Session()
{
	SocketUtils::Close(_socket);
}

HANDLE Session::GetHandle()
{
	return reinterpret_cast<HANDLE>(_socket);
}

void Session::Dispatch(IocpEvent* iocpEvent, int32 numOfBytes)
{

}
```

<div class="notice">
  {{ notice-5 | markdownify }}
</div>

# --------------------------------------------------------------------------------
#### NetAddress 클래스에 사용되는 매크로 추가
# --------------------------------------------------------------------------------
#### Types.h
```cpp
#define size16(val)		static_cast<int16>(sizeof(val))
#define size32(val)		static_cast<int32>(sizeof(val))
#define len16(arr)		static_cast<int16>(sizeof(arr)/sizeof(arr[0]))
#define len32(arr)		static_cast<int32>(sizeof(arr)/sizeof(arr[0]))
```
# --------------------------------------------------------------------------------
#### SocketUtils 클래스에 NetAddress 클래스를 매개변수로 한 Bind 함수 추가
# --------------------------------------------------------------------------------
#### SocketUtils.h
```cpp
#include "NetAddress.h"

class SocketUtils
{
public:
	static bool Bind(SOCKET socket, NetAddress netAddr);
}
```

#### SocketUtils.cpp
```cpp
bool SocketUtils::Bind(SOCKET socket, NetAddress netAddr)
{
	return SOCKET_ERROR != ::bind(socket, reinterpret_cast<const SOCKADDR*>(&netAddr.GetSockAddr()), sizeof(SOCKADDR_IN));
}
```
# --------------------------------------------------------------------------------
#### 추가한 내용들을 활용한 IOCP 모델
# --------------------------------------------------------------------------------
#### Server.h
```cpp
#include "pch.h"
#include "ThreadManager.h"
#include "Listener.h"

int main()
{
	SocketUtils::Init();

	// listen socket
	Listener listener;

	// session의 접속 요청을 받을 준비 시작
	listener.StartAccept(NetAddress(L"127.0.0.1", 7777));

	// WorkerThreads 생성
	for (int32 i = 0; i < 5; i++)
	{
		GThreadManager->Launch([=]()
			{
				while (true)
				{
					// CP 작업 처리
					GIocpCore.Dispatch();
				}
			});
	}

	GThreadManager->Join();
	
	SocketUtils::Clear();	
}
```

출처: [인프런: 게임 프로그래머 입문 올인원][source]

[source]: https://www.inflearn.com/course/%EA%B2%8C%EC%9E%84-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-%EC%9E%85%EB%AC%B8-%EC%98%AC%EC%9D%B8%EC%9B%90-rookiss/dashboard