---
title: "[게임 프로그래머 입문 올인원] RecvBuffer, SendBuffer"
date: 2025-02-25
categories:
  - 게임 프로그래머 입문 올인원
tags:
  - 게임 서버 엔진
---



{% capture notice-1 %}
* TCP 연결 방식은 경계의 개념이 없기 때문에 받은 데이터가 완전체일 때만 처리하도록 해야 함
* 따라서, 받은 데이터는 쌓아서 처리할 수 있을 때만 처리하도록 해야 함
{% endcapture %}

{% capture notice-2 %}
* RecvBuffer를 나타내는 클래스
* read, write 두 개의 커서를 사용하며, 두 커서가 만나게 되면 처음으로 되돌아가게 되며, 이를 위해 buffer size를 미리 크게 만들어 둠
* 남은 공간이 별로 없으면 데이터를 복사하여 buffer 앞으로 이동함
* 위와 같은 방법으로 데이터들이 buffer size를 벗어나지 않게 함
{% endcapture %}

{% capture notice-3 %}
* SendBuffer를 나타내는 클래스
* 패킷의 전체가 다 보내져야 완료 통지가 옴
* Session끼리 공유하는 SendBuffer를 만들어서 보낼 데이터의 내용을 SendBuffer에 복사하고 그 내용을 받아야 하는 모든 Session을 SendBuffer에 연결하여 데이터를 송신함
* 위와 같이 활용하기 위해 스마트 포인터를 사용함
{% endcapture %}

{% capture notice-4 %}
* GameClient를 표현하는 Session 클래스
{% endcapture %}

{% capture notice-5 %}
* GameSession들을 관리하는 클래스
{% endcapture %}



<div class="notice">
  {{ notice-1 | markdownify }}
</div>

# --------------------------------------------------------------------------------
#### Network 필터에 RecvBuffer, SendBuffer 클래스 추가
# --------------------------------------------------------------------------------
#### RecvBuffer.h
```cpp
class RecvBuffer
{
	enum { BUFFER_COUNT = 10 };

public:
	RecvBuffer(int32 bufferSize);
	~RecvBuffer();

	void Clean();
	bool OnRead(int32 numOfBytes);
	bool OnWrite(int32 numOfBytes);

	BYTE* ReadPos() { return &_buffer[_readPos]; }
	BYTE* WritePos() { return &_buffer[_writePos]; }
	int32 DataSize() { return _writePos - _readPos; }
	int32 FreeSize() { return _capacity - _writePos; }

private:
	// 전체 버퍼 크기
	int32 _capacity = 0;
	// 버퍼 하나의 크기
	int32 _bufferSize = 0;
	int32 _readPos = 0;
	int32 _writePos = 0;
	vector<BYTE> _buffer;
};
```

#### RecvBuffer.cpp
```cpp
#include "pch.h"
#include "RecvBuffer.h"

RecvBuffer::RecvBuffer(int32 bufferSize) : _bufferSize(bufferSize)
{
	_capacity = bufferSize * BUFFER_COUNT;
	_buffer.resize(_capacity);
}

RecvBuffer::~RecvBuffer()
{
}

void RecvBuffer::Clean()
{
	int32 dataSize = DataSize();
	if (dataSize == 0)
	{
		// read, write 커서가 만나면 초기화
		_readPos = _writePos = 0;
	}
	else
	{
		// 남은 공간이 별로 없으면 데어터를 복사하여 buffer 앞으로 이동
		if (FreeSize() < _bufferSize)
		{
			::memcpy(&_buffer[0], &_buffer[_readPos], dataSize);
			_readPos = 0;
			_writePos = dataSize;
		}
	}
}

bool RecvBuffer::OnRead(int32 numOfBytes)
{
	// 남은 데이터의 크기가 한 번에 읽는 데이터의 크기보다 적으면 리턴
	if (numOfBytes > DataSize())
		return false;

	_readPos += numOfBytes;
	return true;
}

bool RecvBuffer::OnWrite(int32 numOfBytes)
{
	// 남은 공간이 한 번에 쓰는 데이터의 크기보다 적으면 리턴
	if (numOfBytes > FreeSize())
		return false;

	_writePos += numOfBytes;
	return true;
}
```

<div class="notice">
  {{ notice-2 | markdownify }}
</div>

#### SendBuffer.h
```cpp
class SendBuffer : enable_shared_from_this<SendBuffer>
{
public:
	SendBuffer(int32 bufferSize);
	~SendBuffer();

	BYTE* Buffer() { return _buffer.data(); }
	int32 WriteSize() { return _writeSize; }
	int32 Capacity() { return static_cast<int32>(_buffer.size()); }

	void CopyData(void* data, int32 len);

private:
	vector<BYTE> _buffer;
	int32 _writeSize = 0;
};
```

#### SendBuffer.cpp
```cpp
#include "pch.h"
#include "SendBuffer.h"

SendBuffer::SendBuffer(int32 bufferSize)
{
	_buffer.resize(bufferSize);
}

SendBuffer::~SendBuffer()
{
}

void SendBuffer::CopyData(void* data, int32 len)
{
	assert(Capacity() >= len);
	::memcpy(_buffer.data(), data, len);
	_writeSize = len;
}
```

<div class="notice">
  {{ notice-3 | markdownify }}
</div>

# --------------------------------------------------------------------------------
#### Session 클래스에 recvBuffer 멤버 변수 추가 및 생성자, RegisterRecv, ProcessRecv 함수 추가된 멤버 변수에 맞게 코드 수정
# --------------------------------------------------------------------------------
#### Session.h
```cpp
#include "RecvBuffer.h"

class Session : public IocpObject
{
	enum
	{
		BUFFER_SIZE = 0x10000, // 64KB
	};

private:
	// 수신
	RecvBuffer				_recvBuffer;
};
```

#### Session.cpp
```cpp
Session::Session() : _recvBuffer(BUFFER_SIZE)
{
	_socket = SocketUtils::CreateSocket();
}

void Session::RegisterRecv()
{
	if (IsConnected() == false)
		return;

	_recvEvent.Init();
	// 수신 이벤트와 session 연결
	_recvEvent.owner = shared_from_this();

	WSABUF wsaBuf;
	wsaBuf.buf = reinterpret_cast<char*>(_recvBuffer.WritePos());
	wsaBuf.len = _recvBuffer.FreeSize();

	DWORD numOfBytes = 0;
	DWORD flags = 0;
	// 수신 시도
	if (SOCKET_ERROR == ::WSARecv(_socket, &wsaBuf, 1, OUT & numOfBytes, OUT & flags, &_recvEvent, nullptr))
	{
		int32 errorCode = ::WSAGetLastError();
		if (errorCode != WSA_IO_PENDING)
		{
			// 수신 실패, 오류 알림
			HandleError(errorCode);
			_recvEvent.owner = nullptr;
		}
	}
}

void Session::ProcessRecv(int32 numOfBytes)
{
	_recvEvent.owner = nullptr;

	// 데이터의 크기가 0이면 연결 해제
	if (numOfBytes == 0)
	{
		Disconnect(L"Recv 0");
		return;
	}

	// 수신 버퍼에 기록중 오류 발생 시, 연결 해제
	if (_recvBuffer.OnWrite(numOfBytes) == false)
	{
		Disconnect(L"OnWrite Overflow");
		return;
	}

	// 수신 버퍼의 내용을 읽는중 오류 발생 시, 연결 해제
	int32 dataSize = _recvBuffer.DataSize();
	int32 processLen = OnRecv(_recvBuffer.ReadPos(), dataSize);
	if (processLen < 0 || dataSize < processLen || _recvBuffer.OnRead(processLen) == false)
	{
		Disconnect(L"OnRead Overflow");
		return;
	}

	// 커서 정리
	_recvBuffer.Clean();

	// 수신 이벤트 등록
	RegisterRecv();
}
```
# --------------------------------------------------------------------------------
#### Listener RegisterAccept 함수 추가된 recvBuffer에 맞게 코드 수정
# --------------------------------------------------------------------------------
#### Listener.cpp
```cpp
void Listener::RegisterAccept(IocpEvent* acceptEvent)
{
	// session 생성 후, 접속 이벤트와 연결
	SessionRef session = _service->CreateSession();
	acceptEvent->Init();
	acceptEvent->session = session;

	DWORD bytesReceived = 0;
	// Client와 연결 시도
	if (false == SocketUtils::AcceptEx(_socket, session->GetSocket(), session->_recvBuffer.WritePos(), 0, sizeof(SOCKADDR_IN) + 16, sizeof(SOCKADDR_IN) + 16, OUT &bytesReceived, static_cast<LPOVERLAPPED>(acceptEvent)))
	{
		const int32 errorCode = ::WSAGetLastError();
		if (errorCode != WSA_IO_PENDING)
		{
			// 아직 연결중이라면 재시도
			RegisterAccept(acceptEvent);
		}
	}
}
```
# --------------------------------------------------------------------------------
#### Types에 SendBufferRef 추가
# --------------------------------------------------------------------------------
#### Types.h
```cpp
using SendBufferRef = std::shared_ptr<class SendBuffer>;
```
# --------------------------------------------------------------------------------
#### Session 클래스에 SendQueue, sendEvent 멤버 변수 추가 및 Send, RegisterSend, ProcessSend 함수 추가된 멤버 변수에 맞게 코드 수정
# --------------------------------------------------------------------------------
#### Session.h
```cpp
class Session : public IocpObject
{
public:
	void Send(SendBufferRef sendBuffer);
	void ProcessSend(int32 numOfBytes);

private:
	void RegisterSend();

private:
	// 송신
	queue<SendBufferRef>	_sendQueue;
	atomic<bool>			_sendRegistered = false;

private:
	IocpEvent _sendEvent{ EventType::Send };
}
```

#### Session.cpp
```cpp
void Session::Send(SendBufferRef sendBuffer)
{
	bool registerSend = false;

	{
		WRITE_LOCK;
		_sendQueue.push(sendBuffer);
		// 송신중인지 확인
		registerSend = _sendRegistered.exchange(true) == false;
	}

	// CP에 송신 이벤트 등록
	if (registerSend)
		RegisterSend();
}

void Session::RegisterSend()
{
	if (IsConnected() == false)
		return;

	_sendEvent.Init();
	// 송신 이벤트와 session 연결
	_sendEvent.owner = shared_from_this();

	// 보낼 데이터를 sendEvent에 등록
	{
		WRITE_LOCK;

		int32 writeSize = 0;
		while (_sendQueue.empty() == false)
		{
			SendBufferRef sendBuffer = _sendQueue.front();

			writeSize += sendBuffer->WriteSize();
			
			_sendQueue.pop();
			_sendEvent.sendBuffers.push_back(sendBuffer);
		}
	}

	// Scatter-Gather
	// 흩어져 있는 데이터들을 모아서 한 방에 보냄
	vector<WSABUF> wsaBufs;
	wsaBufs.reserve(_sendEvent.sendBuffers.size());
	for (SendBufferRef sendBuffer : _sendEvent.sendBuffers)
	{
		WSABUF wsaBuf;
		wsaBuf.buf = reinterpret_cast<char*>(sendBuffer->Buffer());
		wsaBuf.len = static_cast<LONG>(sendBuffer->WriteSize());
		wsaBufs.push_back(wsaBuf);
	}

	DWORD numOfBytes = 0;
	// 송신 시도
	if (SOCKET_ERROR == ::WSASend(_socket, wsaBufs.data(), static_cast<DWORD>(wsaBufs.size()), OUT & numOfBytes, 0, &_sendEvent, nullptr))
	{
		int32 errorCode = ::WSAGetLastError();
		if (errorCode != WSA_IO_PENDING)
		{
			// 송신 실패, 오류 알림
			HandleError(errorCode);
			_sendEvent.owner = nullptr; 
			_sendEvent.sendBuffers.clear();
			_sendRegistered.store(false);
		}
	}
}

void Session::ProcessSend(int32 numOfBytes)
{
	_sendEvent.owner = nullptr;
	_sendEvent.sendBuffers.clear();

	// 데이터의 크기가 0이면 연결 해제
	if (numOfBytes == 0)
	{
		Disconnect(L"Send 0");
		return;
	}

	OnSend(numOfBytes);

	bool registerSend = false;

	// 보낼 데이터가 있는지 확인
	{
		WRITE_LOCK;
		if (_sendQueue.empty())
			_sendRegistered.store(false);
		else
			registerSend = true;
	}

	// 송신 이벤트 등록
	if (registerSend)
		RegisterSend();
}
```
# --------------------------------------------------------------------------------
#### IocpEvent 구조체에 임시로 sendBuffer 추가
# --------------------------------------------------------------------------------
#### IocpEvnet.h
```cpp
struct IocpEvent : public OVERLAPPED
{
	// 임시 송신 버퍼
	vector<BYTE> buffer;
};
```
# --------------------------------------------------------------------------------
#### CorePch에 SendBuffer 헤더 추가
# --------------------------------------------------------------------------------
#### CorePch.h
```cpp
#include "SendBuffer.h"
```
# --------------------------------------------------------------------------------
#### Server 프로젝트 Main 필터에 GameSession, GameSessionManager 클래스 추가
# --------------------------------------------------------------------------------
#### GameSession.h
```cpp
#include "Session.h"

class GameSession : public Session
{
public:
	~GameSession()
	{
		cout << "~GameSession" << endl;
	}

	virtual void OnConnected() override;
	virtual void OnDisconnected() override;
	virtual int32 OnRecv(BYTE* buffer, int32 len) override;
	virtual void OnSend(int32 len) override;
};
```

#### GameSession.cpp
```cpp
#include "pch.h"
#include "GameSession.h"
#include "GameSessionManager.h"

void GameSession::OnConnected()
{
	GSessionManager.Add(static_pointer_cast<GameSession>(shared_from_this()));
}

void GameSession::OnDisconnected()
{
	GSessionManager.Remove(static_pointer_cast<GameSession>(shared_from_this()));
}

int32 GameSession::OnRecv(BYTE* buffer, int32 len)
{
	cout << "OnRecv Len = " << len << endl;

	SendBufferRef sendBuffer = make_shared<SendBuffer>(4096);
	sendBuffer->CopyData(buffer, len);
	
	// 모든 session에 알리기
	GSessionManager.Broadcast(sendBuffer);

	return len;
}

void GameSession::OnSend(int32 len)
{
	cout << "OnSend Len = " << len << endl;
}
```

<div class="notice">
  {{ notice-4 | markdownify }}
</div>

#### GameSessionManager.h
```cpp
class GameSession;

using GameSessionRef = shared_ptr<GameSession>;

class GameSessionManager
{
public:
	void Add(GameSessionRef session);
	void Remove(GameSessionRef session);
	void Broadcast(SendBufferRef sendBuffer);

private:
	USE_LOCK;
	set<GameSessionRef> _sessions;
};

extern GameSessionManager GSessionManager;
```

#### GameSessionManager.cpp
```cpp
#include "pch.h"
#include "GameSessionManager.h"
#include "GameSession.h"

GameSessionManager GSessionManager;

void GameSessionManager::Add(GameSessionRef session)
{
	WRITE_LOCK;
	_sessions.insert(session);
}

void GameSessionManager::Remove(GameSessionRef session)
{
	WRITE_LOCK;
	_sessions.erase(session);
}

void GameSessionManager::Broadcast(SendBufferRef sendBuffer)
{
	WRITE_LOCK;
	for (GameSessionRef session : _sessions)
	{
		session->Send(sendBuffer);
	}
}
```

<div class="notice">
  {{ notice-5 | markdownify }}
</div>

# --------------------------------------------------------------------------------
#### DummyClient에 ServerSession 클래스 추가 후 통신을 위한 코드 추가
# --------------------------------------------------------------------------------
#### DummyClient.cpp
```cpp
#include "pch.h"
#include "ThreadManager.h"
#include "Service.h"
#include "Session.h"

char sendData[] = "Hello World";

class ServerSession : public Session
{
public:
	~ServerSession()
	{
		cout << "~ServerSession" << endl;
	}

	virtual void OnConnected() override
	{
		cout << "Connected To Server" << endl;

		SendBufferRef sendBuffer = make_shared<SendBuffer>(4096);
		sendBuffer->CopyData(sendData, sizeof(sendData));
		Send(sendBuffer);
	}

	virtual int32 OnRecv(BYTE* buffer, int32 len) override
	{
		cout << "OnRecv Len = " << len << endl;

		this_thread::sleep_for(0.1s);

		SendBufferRef sendBuffer = make_shared<SendBuffer>(4096);
		sendBuffer->CopyData(sendData, sizeof(sendData));
		Send(sendBuffer);

		return len;
	}

	virtual void OnSend(int32 len) override
	{
		cout << "OnSend Len = " << len << endl;
	}

	virtual void OnDisconnected() override
	{
		cout << "Disconnected" << endl;
	}
};

int main()
{
	this_thread::sleep_for(1s);

	SocketUtils::Init();

	ClientServiceRef service = make_shared<ClientService>(
		NetAddress(L"127.0.0.1", 7777),
		make_shared<IocpCore>(),
		[]() { return make_shared<ServerSession>(); },
		5);

	assert(service->Start());

	for (int32 i = 0; i < 5; i++)
	{
		GThreadManager->Launch([=]()
			{
				while (true)
				{
					service->GetIocpCore()->Dispatch();
				}
			});
	}

	GThreadManager->Join();

	SocketUtils::Clear();
}
```
# --------------------------------------------------------------------------------
#### ClientService Start 함수에 통신을 위한 코드 추가
# --------------------------------------------------------------------------------
#### Service.cpp
```cpp
bool ClientService::Start()
{
	if (CanStart() == false)
		return false;

	const int32 sessionCount = GetMaxSessionCount();
	for (int32 i = 0; i < sessionCount; i++)
	{
		SessionRef session = CreateSession();
		if (session->Connect() == false)
			return false;
	}

	return true;
}
```

출처: [인프런: 게임 프로그래머 입문 올인원][source]

[source]: https://www.inflearn.com/course/%EA%B2%8C%EC%9E%84-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-%EC%9E%85%EB%AC%B8-%EC%98%AC%EC%9D%B8%EC%9B%90-rookiss/dashboard